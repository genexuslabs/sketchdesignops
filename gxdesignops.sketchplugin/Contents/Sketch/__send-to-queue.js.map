{"version":3,"sources":["webpack://exports/webpack/bootstrap","webpack://exports/./node_modules/@skpm/child_process/index.js","webpack://exports/./node_modules/@skpm/child_process/lib/exec.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFile.js","webpack://exports/./node_modules/@skpm/child_process/lib/execFileSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/execSync.js","webpack://exports/./node_modules/@skpm/child_process/lib/handleData.js","webpack://exports/./node_modules/@skpm/child_process/lib/normalizeSpawnArguments.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawn.js","webpack://exports/./node_modules/@skpm/child_process/lib/spawnSync.js","webpack://exports/./src/constants.js","webpack://exports/./src/send-to-queue.js","webpack://exports/./src/utils.js","webpack://exports/external \"buffer\"","webpack://exports/external \"events\"","webpack://exports/external \"sketch\"","webpack://exports/external \"sketch/settings\"","webpack://exports/external \"stream\""],"names":["SettingKeys","S3_BUCKET","S3_SECRET_KEY","S3_ACCESS_KEY","ENABLE_S3","DESIGN_QUEUE","doc","sketch","getSelectedDocument","queuePath","getQueuePath","copySketch","images","fileName","path","getFileAndQueueName","console","log","localeCompare","spawnSync","shell","copyImages","fromCopyFile","decodeURIComponent","toCopyFile","enableS3","Settings","settingForKey","s3Bucket","s3SecretKey","s3AccessKey","uploadToS3","ret","copyFile","UI","message","branch","build","replace","trim","firstIndex","indexOf","lastIndex","lastIndexOf","betweenText","substr","withoutVersionPath","branchAndBuild","items","split","length","file","bucketName","s3Secret","s3Key","dateValue","execSync","toString","bucket","resource","contentType","signature","stringToSign","signMethod","signatureObj","curl_command","test","spawn","status","Error","stderr","generateArtboardImages","document","artboards","pages","forEach","page","layers","layer","type","name","startsWith","push","exportPath","ab","export","output","exportLayer","exportFormats","formats","Array","scales","prefixes","ef","fileFormat","size","options","join","child","imageFolder","askQueuePath","undefined","getInputFromUser","initialValue","err","value","setSettingForKey"],"mappings":";;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,sBAAsB,mBAAO,CAAC,kEAAY;AAC1C,0BAA0B,mBAAO,CAAC,0EAAgB;AAClD,uBAAuB,mBAAO,CAAC,oEAAa;AAC5C,2BAA2B,mBAAO,CAAC,4EAAiB;AACpD,8BAA8B,mBAAO,CAAC,kFAAoB;AAC1D,0BAA0B,mBAAO,CAAC,0EAAgB;;;;;;;;;;;;ACLlD,eAAe,mBAAO,CAAC,sEAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA,YAAY,mBAAO,CAAC,gEAAS;AAC7B,iBAAiB,mBAAO,CAAC,0EAAc;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1KA,gBAAgB,mBAAO,CAAC,wEAAa;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,yDAAyD;AACzD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC5DA,mBAAmB,mBAAO,CAAC,8EAAgB;;AAE3C;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;;AAE5B;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,mBAAmB,mBAAO,CAAC,sBAAQ;AACnC,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,eAAe,mBAAO,CAAC,sBAAQ;;AAE/B,gBAAgB,mBAAO,CAAC,wEAAa;AACrC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;AC1OA;AACA,iBAAiB,mBAAO,CAAC,0EAAc;AACvC,8BAA8B,mBAAO,CAAC,oGAA2B;;AAEjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AClHA;AAAA;AAAO,IAAMA,WAAW,GAAG;AACvBC,WAAS,EAAG,UADW;AAEvBC,eAAa,EAA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","file":"__send-to-queue.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/send-to-queue.js\");\n","module.exports.exec = require('./lib/exec')\nmodule.exports.execFile = require('./lib/execFile')\nmodule.exports.spawn = require('./lib/spawn')\nmodule.exports.spawnSync = require('./lib/spawnSync')\nmodule.exports.execFileSync = require('./lib/execFileSync')\nmodule.exports.execSync = require('./lib/execSync')\n","var execFile = require('./execFile')\n\nfunction normalizeExecArgs(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = undefined\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options,\n    callback: callback\n  }\n}\n\nmodule.exports = function exec(command, options, callback) {\n  var opts = normalizeExecArgs(command, options, callback)\n  return execFile(opts.file, opts.options, opts.callback)\n}\n","/* globals NSMutableData, NSData */\nvar spawn = require('./spawn')\nvar handleData = require('./handleData')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nfunction concatData(prev, data) {\n  prev.appendData(data)\n  return prev\n}\n\nmodule.exports = function execFile(file, args, options, callback) {\n  var defaultOptions = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: undefined,\n    env: undefined,\n    shell: false\n  }\n\n  if (typeof args === 'function') {\n    // function (file, callback)\n    callback = args\n    args = []\n    options = defaultOptions\n  } else if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options, callback)\n    callback = options\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file, args, options, callback)\n    options = Object.assign(defaultOptions, options)\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell\n  })\n\n  var encoding = options.encoding\n  var _stdout = []\n  var _stderr = []\n\n  var stdoutLen = 0\n  var stderrLen = 0\n  var killed = false\n  var exited = false\n  var timeoutId\n\n  var ex = null\n\n  var cmd = file\n\n  function exithandler(code, signal) {\n    if (exited) return\n    exited = true\n\n    if (timeoutId) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n\n    if (!callback) return\n\n    // merge chunks\n    var stdout = handleData(\n      NSData.dataWithData(_stdout.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n    var stderr = handleData(\n      NSData.dataWithData(_stderr.reduce(concatData, NSMutableData.data())),\n      encoding\n    )\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null, stdout, stderr)\n      return\n    }\n\n    if (args.length !== 0) {\n      cmd += ' ' + args.join(' ')\n    }\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr)\n      ex.killed = child.killed || killed\n      ex.code = code\n      ex.signal = signal\n    }\n\n    ex.cmd = cmd\n    callback(ex, stdout, stderr)\n  }\n\n  function errorhandler(e) {\n    ex = e\n\n    exithandler()\n  }\n\n  function kill() {\n    killed = true\n    try {\n      child.kill(options.killSignal)\n    } catch (e) {\n      ex = e\n      exithandler()\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill()\n      timeoutId = null\n    }, options.timeout)\n  }\n\n  if (child.stdout) {\n    child.stdout.setEncoding('NSData')\n    child.stdout.on('data', function onChildStdout(chunk) {\n      stdoutLen += chunk.length()\n      if (stdoutLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stdout')\n        kill()\n      } else {\n        _stdout.push(chunk)\n      }\n    })\n  }\n\n  if (child.stderr) {\n    child.stderr.setEncoding('NSData')\n    child.stderr.on('data', function onChildStderr(chunk) {\n      stderrLen += chunk.length()\n\n      if (stderrLen > options.maxBuffer) {\n        ex = new Error('ERR_CHILD_PROCESS_STDIO_MAXBUFFER stderr')\n        kill()\n      } else {\n        _stderr.push(chunk)\n      }\n    })\n  }\n\n  child.addListener('close', exithandler)\n  child.addListener('error', errorhandler)\n\n  return child\n}\n","var spawnSync = require('./spawnSync')\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(Number.isInteger(timeout) && timeout >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.timeout')\n  }\n}\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new Error('ERR_OUT_OF_RANGE options.maxBuffer')\n  }\n}\n\nmodule.exports = function execFileSync(file, args, options) {\n  var defaultOptions = {\n    encoding: 'buffer',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null,\n    shell: false\n  }\n\n  if (typeof args === 'object' && !Array.isArray(args)) {\n    // function (file, options)\n    options = Object.assign(defaultOptions, args)\n    args = []\n  } else {\n    // function (file)\n    options = Object.assign(defaultOptions, options || {})\n  }\n\n  // Validate the timeout, if present.\n  validateTimeout(options.timeout)\n\n  // Validate maxBuffer, if present.\n  validateMaxBuffer(options.maxBuffer)\n\n  var child = spawnSync(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    shell: options.shell,\n    encoding: options.encoding,\n    stdio: ['pipe', 'pipe', 'inherit']\n  })\n\n  if (child.status !== 0) {\n    var error = new Error('Failed to run: ' + String(child.stderr))\n    error.pid = child.pid\n    error.status = child.status\n    error.stdout = child.stdout\n    error.stderr = child.stderr\n    throw error\n  }\n\n  return child.stdout\n}\n","var execFileSync = require('./execFileSync')\n\nfunction normalizeExecArgs(command, options) {\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n  options.shell = typeof options.shell === 'string' ? options.shell : true\n\n  return {\n    file: command,\n    options: options\n  }\n}\n\nmodule.exports = function execSync(command, options) {\n  var opts = normalizeExecArgs(command, options)\n  return execFileSync(opts.file, opts.options)\n}\n","var Buffer = require('buffer').Buffer\n\nfunction handleBuffer(buffer, encoding) {\n  if (encoding === 'buffer') {\n    return buffer\n  }\n  if (encoding === 'NSData') {\n    return buffer.toNSData()\n  }\n  return buffer.toString(encoding)\n}\n\nmodule.exports = function handleData(data, encoding) {\n  var buffer = Buffer.from(data)\n\n  return handleBuffer(buffer, encoding)\n}\n","module.exports = function normalizeSpawnArguments(file, args, options) {\n  if (typeof file !== 'string' || file.length === 0) {\n    throw new Error('ERR_INVALID_ARG_TYPE')\n  }\n\n  if (Array.isArray(args)) {\n    args = args.slice(0)\n  } else if (\n    args !== undefined &&\n    (args === null || typeof args !== 'object')\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE args')\n  } else {\n    options = args\n    args = []\n  }\n\n  if (options === undefined) {\n    options = {}\n  } else if (options === null || typeof options !== 'object') {\n    throw new Error('ERR_INVALID_ARG_TYPE options')\n  }\n\n  // Validate the cwd, if present.\n  if (options.cwd != null && typeof options.cwd !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.cwd')\n  }\n\n  // Validate detached, if present.\n  if (options.detached != null && typeof options.detached !== 'boolean') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.detached')\n  }\n\n  // Validate the uid, if present.\n  if (options.uid != null && !Number.isInteger(options.uid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.uid')\n  }\n\n  // Validate the gid, if present.\n  if (options.gid != null && !Number.isInteger(options.gid)) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.gid')\n  }\n\n  // Validate the shell, if present.\n  if (\n    options.shell != null &&\n    typeof options.shell !== 'boolean' &&\n    typeof options.shell !== 'string'\n  ) {\n    throw new Error('ERR_INVALID_ARG_TYPE options.shell')\n  }\n\n  // Validate argv0, if present.\n  if (options.argv0 != null && typeof options.argv0 !== 'string') {\n    throw new Error('ERR_INVALID_ARG_TYPE options.argv0')\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = Object.assign({}, options)\n\n  if (options.shell) {\n    var command = [file].concat(args).join(' ')\n\n    if (typeof options.shell === 'string') {\n      file = options.shell\n    } else {\n      file = '/bin/bash'\n    }\n    args = ['-l', '-c', command]\n  }\n\n  if (typeof options.argv0 === 'string') {\n    args.unshift(options.argv0)\n  }\n\n  var stdio = ['pipe', 'pipe', 'pipe']\n\n  if (typeof options.stdio === 'string') {\n    if (options.stdio === 'inherit') {\n      stdio = [0, 1, 2]\n    } else {\n      stdio = [options.stdio, options.stdio, options.stdio]\n    }\n  } else if (Array.isArray(options.stdio)) {\n    if (options.stdio[0] || options.stdio[0] === 0) {\n      if (options.stdio[0] === 'inherit') {\n        stdio[0] = 0\n      } else {\n        stdio[0] = options.stdio[0]\n      }\n    }\n    if (options.stdio[1] || options.stdio[1] === 0) {\n      if (options.stdio[1] === 'inherit') {\n        stdio[1] = 1\n      } else {\n        stdio[1] = options.stdio[1]\n      }\n    }\n    if (options.stdio[2] || options.stdio[2] === 0) {\n      if (options.stdio[2] === 'inherit') {\n        stdio[2] = 2\n      } else {\n        stdio[2] = options.stdio[2]\n      }\n    }\n  }\n\n  var env = options.env\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: env,\n    stdio: stdio\n  }\n}\n","/* globals NSPipe, NSTask, NSArray, NSString, coscript, __mocha__ */\nvar Buffer = require('buffer').Buffer\nvar EventEmitter = require('events')\nvar Readable = require('stream').Readable\nvar Writable = require('stream').Writable\n\nvar spawnSync = require('./spawnSync')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nmodule.exports = function spawn(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  var result = new EventEmitter()\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    var resolvedCommand = String(whichChild.stdout || '').trim()\n    if (whichChild.err || !resolvedCommand.length) {\n      result.stderr = new EventEmitter()\n      result.stdout = new EventEmitter()\n\n      result.pid = '-1'\n\n      result.stderr.setEncoding = function setEncoding(encoding) {\n        result.stderr.encoding = encoding\n      }\n      result.stdout.setEncoding = function setEncoding(encoding) {\n        result.stdout.encoding = encoding\n      }\n      if (!resolvedCommand.length) {\n        result.emit('error', new Error(String(opts.file) + ' ENOENT'))\n      } else {\n        result.emit('error', whichChild.err)\n      }\n      return result\n    }\n    return spawn(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  result.killed = false\n\n  var fiber = coscript.createFiber()\n\n  var task\n  var signal = null\n\n  var readingStderr = false\n  var readingStdout = false\n\n  result.stderr = new Readable({\n    read: function read() {\n      readingStderr = true\n    }\n  })\n  result.stdout = new Readable({\n    read: function read() {\n      readingStdout = true\n    }\n  })\n\n  function onStdout(data) {\n    if (data && data.length() && readingStdout) {\n      if (!result.stdout.push(Buffer.from(data))) {\n        readingStdout = false\n        task\n          .standardOutput()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n  function onStderr(data) {\n    if (data && data.length() && readingStderr) {\n      if (!result.stderr.push(Buffer.from(data))) {\n        readingStderr = false\n        task\n          .standardError()\n          .fileHandleForReading()\n          .setReadabilityHandler(null)\n      }\n    }\n  }\n\n  result.sdtin = new Writable({\n    write: function write(chunk, encoding, callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .writeData(chunk.toNSData())\n      callback()\n    },\n    final: function finish(callback) {\n      task\n        .standardInput()\n        .fileHandleForWriting()\n        .closeFile()\n      callback()\n    }\n  })\n\n  result.sdtio = [result.sdtin, result.sdtout, result.sdterr]\n\n  try {\n    task = NSTask.alloc().init()\n\n    var inPipe = NSPipe.pipe()\n    var pipe = NSPipe.pipe()\n    var errPipe = NSPipe.pipe()\n\n    task.setStandardInput(inPipe)\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task\n      .standardOutput()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStdout(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n    task\n      .standardError()\n      .fileHandleForReading()\n      .setReadabilityHandler(\n        __mocha__.createBlock_function(\n          'v16@?0@\"NSFileHandle\"8',\n          function readStdOut(fileHandle) {\n            try {\n              onStderr(fileHandle.availableData())\n            } catch (err) {\n              if (\n                typeof process !== 'undefined' &&\n                process.listenerCount &&\n                process.listenerCount('uncaughtException')\n              ) {\n                process.emit('uncaughtException', err, 'uncaughtException')\n              } else {\n                console.error(err)\n              }\n            }\n          }\n        )\n      )\n\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setTerminationHandler(\n      __mocha__.createBlock_function(\n        'v16@?0@\"NSTask\"8',\n        function handleTermination(_task) {\n          try {\n            _task\n              .standardError()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            _task\n              .standardOutput()\n              .fileHandleForReading()\n              .setReadabilityHandler(null)\n            result.stderr.emit('close')\n            result.stdout.emit('close')\n\n            result.killed = true\n\n            result.emit('close', Number(_task.terminationStatus()), signal)\n          } catch (err) {\n            if (\n              typeof process !== 'undefined' &&\n              process.listenerCount &&\n              process.listenerCount('uncaughtException')\n            ) {\n              process.emit('uncaughtException', err, 'uncaughtException')\n            } else {\n              console.error(err)\n            }\n          }\n          fiber.cleanup()\n        }\n      )\n    )\n\n    task.launch()\n  } catch (err) {\n    fiber.cleanup()\n    setImmediate(function() {\n      result.emit('error', err)\n    })\n    return result\n  }\n\n  result.kill = function kill(_signal) {\n    if (!result.killed) {\n      signal = _signal\n      task.terminate()\n    }\n  }\n\n  result.pid = String(task.processIdentifier())\n\n  return result\n}\n","/* globals NSPipe, NSTask, NSArray, NSString */\nvar handleData = require('./handleData')\nvar normalizeSpawnArguments = require('./normalizeSpawnArguments')\n\nfunction spawnSync(_command, _args, _options) {\n  var opts = normalizeSpawnArguments(_command, _args, _options)\n\n  if (opts.file[0] !== '.' && opts.file[0] !== '/' && opts.file[0] !== '~') {\n    // means that someone refered to an executable that might be in the path, let's find it\n    var whichChild = spawnSync(\n      '/bin/bash',\n      ['-l', '-c', 'which ' + opts.file],\n      { encoding: 'utf8' }\n    )\n    if (whichChild.err) {\n      return whichChild\n    }\n    var resolvedCommand = String(whichChild.stdout).trim()\n    if (!resolvedCommand.length) {\n      return {\n        err: new Error(String(opts.file) + ' ENOENT')\n      }\n    }\n    return spawnSync(resolvedCommand, _args, _options)\n  }\n\n  var options = opts.options\n\n  var pipe = NSPipe.pipe()\n  var errPipe = NSPipe.pipe()\n\n  try {\n    var task = NSTask.alloc().init()\n    task.setLaunchPath(\n      NSString.stringWithString(opts.file).stringByExpandingTildeInPath()\n    )\n    task.arguments = NSArray.arrayWithArray(opts.args || [])\n    if (opts.envPairs) {\n      task.environment = opts.envPairs\n    }\n\n    if (options.cwd) {\n      task.setCurrentDirectoryPath(\n        NSString.stringWithString(options.cwd).stringByExpandingTildeInPath()\n      )\n    }\n\n    task.setStandardOutput(pipe)\n    task.setStandardError(errPipe)\n\n    task.launch()\n    task.waitUntilExit()\n\n    var stdoutIgnored = false\n    var stderrIgnored = false\n\n    var data\n    var stdoutValue\n    var stderrValue\n\n    if (opts.stdio[1] === 'ignored') {\n      stdoutIgnored = true\n    } else if (opts.stdio[1] === 1) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.log(stdoutValue)\n    } else if (opts.stdio[1] === 2) {\n      data = pipe.fileHandleForReading().readDataToEndOfFile()\n      stdoutValue = handleData(data, options.encoding || 'buffer')\n      console.error(stdoutValue)\n    }\n\n    if (opts.stdio[2] === 'ignored') {\n      stderrIgnored = true\n    } else if (opts.stdio[2] === 1) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.log(stderrValue)\n    } else if (opts.stdio[2] === 2) {\n      data = errPipe.fileHandleForReading().readDataToEndOfFile()\n      stderrValue = handleData(data, options.encoding || 'buffer')\n      console.error(stderrValue)\n    }\n\n    return {\n      pid: String(task.processIdentifier()),\n      status: Number(task.terminationStatus()),\n      get stdout() {\n        if (stdoutIgnored) {\n          return null\n        }\n        if (stdoutValue) {\n          return stdoutValue\n        }\n        data = pipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      },\n      get stderr() {\n        if (stderrIgnored) {\n          return null\n        }\n        if (stderrValue) {\n          return stdoutValue\n        }\n        data = errPipe.fileHandleForReading().readDataToEndOfFile()\n        return handleData(data, options.encoding || 'buffer')\n      }\n    }\n  } catch (err) {\n    return {\n      err: err\n    }\n  }\n}\n\nmodule.exports = spawnSync\n","\nexport var   SettingKeys = {\n    S3_BUCKET : \"gxBucket\",\n    S3_SECRET_KEY : \"gxS3SecretKey\",\n    S3_ACCESS_KEY : \"gxS3AccessKey\",\n    ENABLE_S3: \"gxS3Enabled\" ,\n    DESIGN_QUEUE: \"DesignOpsQueue\",\n};\n\n","import sketch from 'sketch';\nimport { copyFile, copyImages, getFileAndQueueName , getQueuePath, uploadToS3} from './utils';\nimport { spawnSync, execSync } from '@skpm/child_process';\nimport Settings from 'sketch/settings';\nimport {  SettingKeys} from './constants';\n\n\n\nexport default function() {\n  const doc = sketch.getSelectedDocument()\n  var queuePath = getQueuePath();\n  if (queuePath)\n    copySketch(queuePath, doc, true);\n}\n\n\nexport function copySketch(queuePath, doc, images) {\n  var fileName;\n  var path = queuePath;\n  ({ fileName, queuePath } = getFileAndQueueName(doc, path));\n  console.log(\"copy to queue:\" + queuePath);\n  if (queuePath.localeCompare(path) != 0) {\n    spawnSync('mkdir', [\"-p\", queuePath], { shell: true });\n  }\n  if (images)\n    copyImages(queuePath, fileName, doc);\n  var fromCopyFile = decodeURIComponent(doc.path);\n  var toCopyFile = queuePath + fileName;\n\n let enableS3 = Settings.settingForKey(SettingKeys.ENABLE_S3) == 1\n let s3Bucket = Settings.settingForKey(SettingKeys.S3_BUCKET)\n let s3SecretKey = Settings.settingForKey(SettingKeys.S3_SECRET_KEY)\n let s3AccessKey = Settings.settingForKey(SettingKeys.S3_ACCESS_KEY)\n \n  if (enableS3) {\n    console.log(\"uploading \" + toCopyFile)\n    console.log(\"fileName \" + fileName)\n    uploadToS3(fileName, fromCopyFile, s3Bucket, s3SecretKey, s3AccessKey );\n  }\n  else\n  {\n    const ret = copyFile(fromCopyFile, toCopyFile);\n    if (!ret) {\n      sketch.UI.message(\"ðŸ˜” Some error occurs, see console for further details\");\n    }\n    else {\n      sketch.UI.message(\"Copied to Design Ops Queue ! ðŸ’š\");\n    }\n  }\n}","import sketch from 'sketch';\n\nimport { spawnSync, execSync } from '@skpm/child_process';\n\nexport function getFileAndQueueName(doc, queuePath) {\n    var branch = \"\";\n    var build = \"\";\n    var fileName = decodeURIComponent(doc.path).replace(/^.*[\\\\\\/]/, '').trim();\n    var firstIndex = fileName.indexOf(\"(\");\n    var lastIndex = fileName.lastIndexOf(\")\");\n    var betweenText = fileName.substr(0, firstIndex);\n    if (firstIndex > 0 && lastIndex > 0 && lastIndex > firstIndex  ) {\n        var withoutVersionPath = fileName.substr(0, firstIndex).trim() + \".sketch\";\n        var branchAndBuild = fileName.substr(firstIndex + 1, lastIndex - firstIndex - 1).trim();\n        var items = branchAndBuild.split(\"@\");\n        if (items.length == 2) {\n            branch = items[0].trim();\n            build = items[1].trim();\n            queuePath = queuePath + branch + \"/\" + build + \"/\";\n            fileName = withoutVersionPath;\n        }\n    }\n    return { fileName, queuePath };\n}\n\nexport function uploadToS3(fileName, file, bucketName, s3Secret, s3Key) {\n \n  fileName = fileName.replace(/[^a-z0-9.]/gi, '_');\n  var dateValue = execSync(\"date -R\").toString().replace(/\\r?\\n|\\r/, \"\");\n  console.log(\"Date:\" + dateValue);\n  var bucket = bucketName;\n  var resource = `/${bucket}/${fileName}`;\n  var contentType = \"application/x-compressed-tar\";\n  var signature;\n  var stringToSign = `\"PUT\\n\\napplication/x-compressed-tar\\n${dateValue}\\n${resource}\"`;\n  console.log(stringToSign);\n\n  var signMethod = `echo -en ${stringToSign} | openssl sha1 -hmac ${s3Secret} -binary | base64`;\n  console.log(signMethod);\n  var signatureObj = execSync(signMethod);\n  if (signatureObj)\n  {\n    signature = signatureObj.toString().replace(/\\r?\\n|\\r/, \"\");\n    console.log(\"Signature: \" + signature.toString());\n  }  \n  const curl_command =  `curl -X PUT -T \"${file}\" -H \"Host: ${bucket}.s3.amazonaws.com\" -H \"Date: ${dateValue}\" -H \"Content-Type: ${contentType}\" -H \"Authorization: AWS ${s3Key}:${signature}\" https://${bucket}.s3.amazonaws.com/${fileName}`;\n  console.log(curl_command);\n  var test = execSync(curl_command);\n  if (test)\n    console.log(test.toString()); \n}\n\nexport function copyFile(fromCopyFile, toCopyFile) {\n    console.log(\"Copying \" + fromCopyFile);\n    console.log(\"To \" + toCopyFile);\n    const spawn = spawnSync('cp', [\n        \"'\" + fromCopyFile + \"'\",\n        \"'\" + toCopyFile + \"'\"\n    ], \n    { shell: true });\n    if (spawn.status > 0) {\n        console.log(Error(spawn.stderr));\n        return false;\n    }\n    else {\n        return true;\n    }\n}\nexport function generateArtboardImages(document, path) {\n  var artboards = [];\n  \n  document.pages.forEach(page => {\n    page.layers.forEach(layer => {\n      // Get only artboards and skip if artboard name starts with underscore\n      if ( layer.type == 'Artboard' && !layer.name.startsWith('_') ) {\n        artboards.push(layer)\n      }\n    });\n    var exportPath = path + page.name + '/';\n   artboards.forEach(ab => {\n      // Export PNG\n      sketch.export(ab, {output: exportPath})\n   });\n  });\n}\n\nvar exportLayer = function (layer, path) {\n\n    if (layer.exportFormats && layer.exportFormats.length > 0) {\n      var formats = new Array();\n      var scales = new Array();\n      var prefixes = new Array();\n      layer.exportFormats.forEach(ef => {\n        formats.push(ef.fileFormat);\n        scales.push(ef.size);\n      });\n      if (layer.name)\n        console.log(\"Exporting \" + layer.name);\n  \n      const options = {\n        output: path,\n        formats: formats.join(\",\"),\n        scales: scales.join(\",\"),\n        prefixes: \"md\"\n      };\n      sketch.export(layer, options);\n    }\n  \n    if (layer.layers) {\n      layer.layers.forEach(child => exportLayer(child, path));\n  \n    }\n  }\n\nexport function copyImages(queuePath, fileName, doc) {\n    var imageFolder = queuePath + fileName.replace(\".sketch\", \"Images\");\n    generateArtboardImages(doc, imageFolder);\n    console.log(\"Images to :\" + imageFolder);\n    doc.pages.forEach(page => {\n        page.layers.forEach(layer => {\n            exportLayer(layer, imageFolder);\n        });\n    });\n}\n\nexport function getQueuePath() {\n    var queuePath = sketch.Settings.settingForKey(\"DesignOpsQueue\");\n    if (queuePath)\n        return queuePath;\n    return askQueuePath();\n}\n\nexport function askQueuePath() {\n    var queuePath = sketch.Settings.settingForKey(\"DesignOpsQueue\");\n    console.log(\"The actual queuePath is :\" + queuePath);\n    if (!(queuePath !== undefined))\n        queuePath = '/Volumes/cable/DesignOpsQueue/';\n    sketch.UI.getInputFromUser(\"Where is the Design Ops Queue\", { initialValue: queuePath }, (err, value) => {\n      if (err) {\n        return null;\n      }\n      console.log(value);\n      queuePath = value;\n      sketch.Settings.setSettingForKey(\"DesignOpsQueue\", queuePath);\n    });\n    return queuePath; \n  }\n","module.exports = require(\"buffer\");","module.exports = require(\"events\");","module.exports = require(\"sketch\");","module.exports = require(\"sketch/settings\");","module.exports = require(\"stream\");"],"sourceRoot":""}